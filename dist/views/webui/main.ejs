<!DOCTYPE html>
<html lang="de">

<head>
    <title>Tisch</title>
    <%- include('../header_common') %>
    <style>
        .card-body::-webkit-scrollbar {
            display: none;
        }

        /* Hide scrollbar for IE, Edge and Firefox */
        .card-body {
            -ms-overflow-style: none;
            /* IE and Edge */
            scrollbar-width: none;
            /* Firefox */
        }
    </style>
</head>

<body id="app">
    <!-- Nav bar -->
    <nav class="navbar navbar-dark bg-dark">
        <div class="container-fluid">

            <div class="btn-group">
                <button type="button" class="btn btn-primary" data-bs-toggle="offcanvas" href="#oc_sessions"
                    role="button" aria-controls="oc_sessions">
                    Sitzungen
                </button>
                <button type="button" class="btn btn-primary dropdown-toggle dropdown-toggle-split"
                    data-bs-toggle="dropdown" aria-expanded="false">
                    <span class="visually-hidden">Toggle Dropdown</span>
                </button>
                <ul class="dropdown-menu">
                    <li><button class="dropdown-item" :disabled="!selectedsession || (selectedSessionState && selectedSessionState.statetype == 5)" aria-label="Move" type="button"
                            data-bs-toggle="offcanvas" data-bs-target="#oc_moveSession"
                            aria-controls="oc_moveSession">Bewegen</button>
                    </li>
                    <li><button class="dropdown-item" :disabled="!selectedsession || (selectedSessionState && selectedSessionState.statetype == 5)" aria-label="Close Session"
                            type="button" @click="this.closeCurrentSession()">Sitzung schlie√üen</button>
                    </li>
                    <li><button class="dropdown-item" :disabled="!selectedsession" href="#">Infos</button></li>
                    </li>
                    <li>
                        <hr class="dropdown-divider">
                    </li>
                    <li>
                    <li><button class="dropdown-item text-danger"  href="#">Logout</button></li>
                    </li>
                </ul>
            </div>


            <div v-if="selectedsession !=null" class="navbar-brand float-right">
                {{selectedsession.table.name}}
            </div>
            <button v-if="selectedSessionState !=null && selectedSessionState.statetype != 5" class="btn btn-primary">
                Kassieren
            </button>
            <button v-else class="btn btn-primary">
                Rechnungen
            </button>
        </div>
    </nav>

    <!-- Bestellungen -->
    <%-include('list_orders') %>


    <!-- Sessions -->
    <%-include('menu_sessions') %>

    <!-- Error Modal -->
    <%-include('../errorModal') %>


    <!-- Vue Js -->
    <script type="module" type="text/javascript">
        import dm from "/vue/datamodel.js";
                import hlp from "/vue/helper.js";

                const { createApp } = Vue;

                let app = createApp({
                    data: () => ({
                        // Data
                        sortedOrders: [],
                        finishedOrders: [],

                        // Sessions
                        activesessions: [],
                        selectedsession: null,
                        selectedSessionState: null,
                        pastsessions: [],
                        showPastSessions: false,

                        // New Session
                        tableGroups: [],
                        tables: [],
                        currentTable: "",
                        currentTG: null,
                        errorNewSession: null,
                    }),

                    // Execute at page load
                    mounted() {
                        // Load Tables and Tablegroups for New Session
                        dm.loadTableGroups().then((r)=>{
                            this.tableGroups=r
                            this.currentTG = this.tableGroups[0]
                        }).catch((err)=>{
                            console.log(err)
                        })
                        
                        // Load Sessions
                        this.fetchSessions()

                    },

                    watch: {
                        // New Session Watch
                        currentTG: 'fetchTables',
                        selectedsession: 'loadSessionData',

                    },

                    // Helper functions
                    methods: {
                        
                        async loadSessionData() {
                            if(!this.selectedsession){
                                return;
                            }
                            this.selectedSessionState = await hlp.getCurrentState(this.selectedsession)
                            // Close offcanvas
                            await hlp.closeOffcanvas("oc_sessions")
                            // Load orders
                            await this.fetchOrders()
                        },

                        async fetchOrders() {
                            if(!this.selectedsession){
                                return;
                            }
                            this.finishedOrders = [];
                            this.sortedOrders = [];
                            this.orders = await dm.loadOrdersFromSession(this.selectedsession.id)
                            if (!this.orders.length) {
                                return;
                            }

                            // Generate sorted and grouped order lists
                            this.orders.forEach((o) => {
                                if (o.currentState.statetype == 3) {
                                    this.finishedOrders.push(o);
                                } else {
                                    this.sortedOrders.push(o);
                                }
                            })
                            // Sort lists
                            // Finished orders latest first
                            this.finishedOrders.sort(function (a, b) {
                                return new Date(b.currentState.created).getTime() - new Date(a
                                    .currentState.created).getTime();
                            });

                        },

                        getTimeFromOrder(order) {
                            return this.getTimeFromTimestamp(order.currentState.created)
                        },

                        getTimeFromTimestamp(ts) {
                            return (new Date(ts).getHours() + "").padStart(2, '0') + ':' + (
                                new Date(ts).getMinutes() + "").padStart(2, '0')
                        },

                        async loadSessionById(sid) {
                            dm.loadSessionById(sid).then((r)=>this.selectedsession=r)
                        },

                        async fetchSessions() {
                            dm.loadSessionsActive().then((r)=>this.activesessions=r)
                            dm.loadSessionsInactive().then((r)=>{
                                this.pastsessions=r
                                console.log(r)
                            })
                        },
                        async fetchTables() {
                            if(!this.currentTG){
                                return;
                            }
                            dm.loadTablesFromTableGroup(this.currentTG).then((r)=>this.tables=r)
                        },
                        async createSession() {
                            if (this.currentTable && this.currentTG) {
                                const requestOptions = {
                                    method: "PUT",
                                    headers: {
                                        "Content-Type": "application/json"
                                    },
                                    body: JSON.stringify({
                                        tid: this.currentTable
                                    })
                                };
                                const response = await fetch("/rest/session",
                                    requestOptions);
                                if (response.status != 200) {
                                    this.errorNewSession = true;
                                } else {
                                    const data = await response.json();
                                    this.selectedsession = await dm.loadSessionById(data.sid);
                                    this.fetchSessions()
                                    hlp.closeOffcanvas("oc_newSession")
                                }
                            }

                        },
                        
                        async moveSession(){
                            if(!this.currentTable || !this.selectedsession){
                                return;
                            }
                            let newSid = await dm.moveSessionToOtherTable(this.selectedsession.id, this.currentTable);
                            this.selectedsession = await dm.loadSessionById(newSid);
                            this.fetchSessions()
                            await hlp.closeOffcanvas("oc_moveSession")
                        },
                        async updateOrderState(oid, stateid) {
                            dm.updateOrderState(oid, stateid)
                            .then(()=>this.fetchOrders())
                            .catch((err)=>console.log("Update Order State failed: " +response.statusText))
                        },

                        async closeCurrentSession(){
                            dm.closeSessionById(this.selectedsession.id).then(()=>{
                                this.fetchSessions()
                                this.selectedsession=null
                                hlp.openOffcanvas("oc_sessions")
                            })
                        },

                        getSessionTimespan(session){
                            let ts1 = this.getTimeFromTimestamp( hlp.getFirstState(session).created)
                            let ts2 = this.getTimeFromTimestamp( hlp.getLastState(session).created)
                            return ts1 + " - " + ts2
                        }

                    }

                });

                app.config.errorHandler = (err, instance, info) => {
                    console.log("Vue App Error", err, info)
                    hlp.makeError("The application has generated an error.", info, err);
                }
                app.mount("#app");



            </script>



</body>

</html>